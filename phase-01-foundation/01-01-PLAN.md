---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
user_setup: []

must_haves:
  truths:
    - "File system watcher detects all state.json changes within 200ms"
    - "Concurrent writes never corrupt state.json files"
    - "State machine enforces valid transitions only"
    - "All types validated with Zod schemas at runtime"
    - "Integration tests cover end-to-end project lifecycle"
  artifacts:
    - path: "src/core/FileSystem.ts"
      provides: "File system abstraction with atomic operations"
      exports: ["IFileSystem", "FileSystem"]
    - path: "src/engine/StateMachine.ts"
      provides: "Project and card state transition logic"
      exports: ["ProjectStateMachine", "CardStateMachine"]
    - path: "src/concurrency/LockManager.ts"
      provides: "POSIX file locking with exponential backoff"
      exports: ["LockManager"]
    - path: "src/watcher/FileWatcher.ts"
      provides: "Real-time file system event detection"
      exports: ["FileWatcher", "WatcherService"]
    - path: "workspace/"
      provides: "Workspace directory structure for projects"
      contains: "inbox|backlog|active|review|completed|failed"
  key_links:
    - from: "src/watcher/FileWatcher.ts"
      to: "src/engine/StateMachine.ts"
      via: "EventDispatcher routes file events to state transitions"
      pattern: "handleStateChangeEvent.*transition"
    - from: "src/core/FileSystem.ts"
      to: "src/concurrency/LockManager.ts"
      via: "Atomic write operations acquire locks first"
      pattern: "writeProject.*acquireLock"
    - from: "src/engine/StateMachine.ts"
      to: "workspace/"
      via: "Folder moves on state transitions"
      pattern: "moveProject.*transition"
---

<objective>
Build the complete foundation layer for the Agentic Workflow Management System, including file system abstraction, state machine, concurrency control, and file watching infrastructure.

Purpose: Establish the core infrastructure that all other system components will depend on. This layer provides file-system-as-source-of-truth, atomic state management, and real-time event detection.

Output: Fully functional foundation layer with comprehensive tests and documentation, ready for workflow engine implementation.
</objective>

<execution_context>
@./.planning/project-task-management-system/README.md
@./.planning/project-task-management-system/phase-01-foundation/01-system-architecture-design.md
@./.planning/project-task-management-system/phase-01-foundation/02-file-system-structure-setup.md
@./.planning/project-task-management-system/phase-01-foundation/03-data-model-types-definition.md
@./.planning/project-task-management-system/phase-01-foundation/04-state-machine-definition.md
@./.planning/project-task-management-system/phase-01-foundation/05-concurrency-security-design.md
@./.planning/project-task-management-system/phase-01-foundation/06-file-watching-infrastructure.md
@./.planning/project-task-management-system/phase-01-foundation/07-core-interfaces-integration-tests.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Project Structure and Dependencies</name>
  <files>package.json, tsconfig.json, bun.lockb</files>
  <action>
    1. Initialize Bun project with TypeScript configuration
    2. Install required dependencies:
       - Runtime: bun (native support)
       - File watching: chokidar
       - Validation: zod
       - Testing: bun:test (built-in)
       - YAML: gray-matter, js-yaml
    3. Configure tsconfig.json for ES2022, strict mode, path aliases
    4. Add scripts: init-workspace, validate-foundation, test, test:coverage
    5. Create directory structure:
       - src/core/, src/engine/, src/concurrency/, src/security/, src/watcher/, src/utils/
       - tests/unit/, tests/integration/, tests/benchmarks/
       - workspace/, docs/
  </action>
  <verify>ls src/ shows all directories; bun test runs without errors; bun install completes</verify>
  <done>Project structure initialized with all dependencies installed and TypeScript configured</done>
</task>

<task type="auto">
  <name>Task 2: Implement File System Abstraction Layer</name>
  <files>src/core/FileSystem.ts, scripts/init-workspace.ts</files>
  <action>
    Implement FileSystem class (IFileSystem interface):
    1. Atomic write operations: write to temp file, fsync, rename (POSIX guarantee)
    2. File locking: use POSIX flock() with exponential backoff (10ms, 40ms, 160ms)
    3. Folder moves: copy-then-delete (never move to ensure atomicity)
    4. Read operations: parse JSON with Zod schema validation
    5. Create init-workspace.ts script to set up workspace/ directory structure
    6. Implement error handling: return Result<T, Error> types (never throw)
    
    Lock implementation:
    - acquireLock(): try 3 times with exponential backoff, timeout after 5s
    - releaseLock(): unlock and close file descriptor
    - withLock<T>(): acquire, execute fn, release (guaranteed cleanup)
  </action>
  <verify>
    - bun test tests/core/FileSystem.test.ts passes
    - bun run init-workspace creates workspace/ directory with all folders
    - Lock tests: concurrent writes never corrupt data
  </verify>
  <done>File system abstraction with atomic writes, file locking, and workspace initialization</done>
</task>

<task type="auto">
  <name>Task 3: Define Data Models and Types</name>
  <files>src/core/types/*.ts, docs/TYPES.md</files>
  <action>
    Create comprehensive type system:
    1. Project types: ProjectId (branded), ProjectState (enum), Priority (1-5), ProjectState schema
    2. Card types: CardId (branded), CardState (enum), CardFrontmatter schema, Card interface
    3. Agent types: AgentId (branded), Capability enum, AgentManifest schema
    4. Notification types: NotificationId, NotificationType enum, Notification schema
    5. Transition types: TransitionRequest, TransitionResult, TransitionError
    6. Utility types: Result<T, E>, AsyncResult<T, E>, DeepPartial<T>
    7. Create Zod schemas for each type (runtime validation)
    8. Generate TypeScript types from Zod schemas using infer<T>
    9. Document all types in docs/TYPES.md with examples and relationships
    
    Export via src/core/types/index.ts for clean imports.
  </action>
  <verify>ts-compiler compiles all types; Zod schemas validate invalid data with clear errors; type tests cover branded types</verify>
  <done>Complete type system with Zod schemas, runtime validation, and comprehensive documentation</done>
</task>

<task type="auto">
  <name>Task 4: Implement State Machine</name>
  <files>src/engine/StateMachine.ts, src/engine/CardStateMachine.ts, src/engine/TransitionOrchestrator.ts</files>
  <action>
    Implement state transition logic:
    1. ProjectStateMachine class with transition handlers:
       - inbox → backlog: validate project, move folder
       - backlog → active: check dependencies, move to active/unassigned
       - active → review: all cards completed + checkpoint_required
       - active → completed: all cards completed + no checkpoint
       - any → failed: card failed, retry_max exceeded
       - failed → backlog: reset retry counters, requeue
    2. CardStateMachine with validation:
       - Validate card transitions (pending → in-progress → completed)
       - Check dependency blocking (block if dependencies incomplete)
       - Find ready cards (unblocked, pending)
    3. TransitionOrchestrator:
       - Check project readiness for target state
       - Update card states based on dependencies
       - Coordinate project and card transitions
    4. All transitions emit notifications via NotificationManager
    5. Transition validation throws TransitionError with clear messages
    6. State updates are atomic (use FileSystem.writeProject with locking)
  </action>
  <verify>bun test tests/engine/StateMachine.test.ts passes; invalid transitions throw errors; valid transitions complete successfully</verify>
  <done>State machine with project/card transitions, validation, and notification emission</done>
</task>

<task type="auto">
  <name>Task 5: Implement Concurrency and Security</name>
  <files>src/concurrency/LockManager.ts, src/concurrency/OptimisticLocking.ts, src/concurrency/ConcurrencyController.ts, src/security/Security.ts, src/security/RateLimiter.ts</files>
  <action>
    Implement concurrency control and security:
    
    LockManager:
    - POSIX flock() wrapper with timeout (5s default)
    - Exponential backoff: 10ms * 4^attempt, max 2560ms
    - withLock<T>() helper for automatic cleanup
    - Release all locks on shutdown
    
    OptimisticLocking:
    - Atomic update with CAS (Compare-And-Swap) pattern
    - atomicUpdate<T>(resourceId, updateFn, maxRetries): read, compute, write-if-version-matches, retry on conflict
    - claimCard(): atomic claim with CAS, only succeeds if card is pending and unclaimed
    
    ConcurrencyController:
    - Global limit: maxConcurrentOperations (default 50)
    - Per-agent limit: maxPerAgentOperations (default 5)
    - Priority queue: sort by priority (1=highest), then enqueue time
    - execute<T>(fn, priority, agentId): queue or execute immediately
    
    SecurityManager:
    - generateToken(type, id, scopes): HMAC-SHA256 signature
    - validateToken(token): verify signature, check expiration
    - authorize(token, requiredScope): validate token, check scopes
    
    RateLimiter:
    - Token bucket algorithm: 1-minute sliding window
    - check(scope, identifier): { allowed, remaining, resetAt }
    - Per-scope limits (agent, user, admin)
  </action>
  <verify>
    - Lock tests: concurrent writers serialize correctly, no corruption
    - CAS tests: conflicting updates retry until success
    - Rate limiter: returns 429 after limit, resets after window
    - Security tests: invalid tokens rejected, scope-based authorization works
  </verify>
  <done>Concurrency control with locks/CAS and security with tokens/rate limiting</done>
</task>

<task type="auto">
  <name>Task 6: Implement File Watching Infrastructure</name>
  <files>src/watcher/FileWatcher.ts, src/watcher/IntegrityChecker.ts, src/watcher/EventDispatcher.ts, src/watcher/WatcherService.ts</files>
  <action>
    Implement real-time file system monitoring:
    
    FileWatcher:
    - Use chokidar to watch workspace/ state folders
    - Filter for state.json files only
    - Debounce events: 100ms stability threshold, 100ms delay
    - Extract projectId and state from path
    - Emit WatchEvent: { type, path, projectId, state, timestamp }
    - Handle errors: log and auto-restart watcher
    
    IntegrityChecker:
    - computeHash(filePath): SHA256 of file content
    - validateJSON(filePath): parse JSON, validate with ProjectStateSchema
    - hasChanged(filePath, previousHash): compare hashes
    
    EventDispatcher:
    - On file watcher event: validate integrity, check if actually changed
    - Detect state transitions: compare previous vs current state
    - Trigger StateMachine.transition() on state change
    - Log all processing with timestamps
    
    WatcherService:
    - Singleton pattern (getInstance returns same instance)
    - start(): initialize watcher and dispatcher
    - stop(): cleanup, release all resources
    - on(event, callback): subscribe to change events
  </action>
  <verify>
    - File watcher detects state.json changes within 200ms
    - Rapid changes (50ms apart) are debounced to single event
    - Corrupted files are detected and logged
    - State transitions trigger automatically on file changes
  </verify>
  <done>File watching with debouncing, integrity checking, and automatic state transitions</done>
</task>

<task type="auto">
  <name>Task 7: Write Integration Tests and Final Validation</name>
  <files>tests/integration/*.test.ts, tests/benchmarks/*.test.ts, scripts/validate-foundation.ts, src/core/README.md</files>
  <action>
    Complete foundation with testing and documentation:
    
    Integration Tests:
    - ProjectLifecycle.test.ts: inbox → backlog → active → completed flow
    - ConcurrentAccess.test.ts: multiple agents, race conditions, deadlocks
    - DependencyResolution.test.ts: card blocking, circular dependency detection
    - FileSystemResilience.test.ts: corrupted files, partial writes, lock timeouts
    
    Performance Benchmarks:
    - FilePerformance.test.ts: 100 reads in < 1000ms, 100 concurrent writes
    - LockContention.test.ts: 50 agents acquiring locks simultaneously
    - StateTransitionBench.test.ts: 1000 transitions in < 10s
    
    Validation Script (scripts/validate-foundation.ts):
    - Test file system operations
    - Test state machine transitions
    - Test concurrency and locking
    - Test file watching
    - Generate pass/fail report
    
    Documentation (src/core/README.md):
    - Complete API reference for all public interfaces
    - Usage examples for each component
    - Type definitions with descriptions
    - Best practices and patterns
  </action>
  <verify>
    - bun test passes all unit, integration, and benchmark tests
    - bun run validate-foundation exits with code 0
    - Test coverage report shows > 90% coverage
    - Performance benchmarks meet targets (< 10ms file read, < 50ms transition)
  </verify>
  <done>Foundation layer complete with integration tests, benchmarks, validation script, and API documentation</done>
</task>

</tasks>

<verification>
Overall foundation layer validation:
- [ ] Workspace directory structure created (inbox, backlog, active, review, completed, failed)
- [ ] File system abstraction passes all tests (atomic writes, locking)
- [ ] Type system compiles without errors, Zod schemas validate correctly
- [ ] State machine enforces valid transitions, rejects invalid ones
- [ ] Concurrency tests pass (no data corruption under load)
- [ ] File watcher detects changes within 200ms, debouncing works
- [ ] Security tokens validate correctly, rate limiting prevents abuse
- [ ] Integration tests cover end-to-end project lifecycle
- [ ] Performance benchmarks meet targets
- [ ] Validation script passes all checks
</verification>

<success_criteria>
Foundation layer is production-ready:
1. All 7 phases implemented and tested
2. > 90% code coverage achieved
3. Performance benchmarks pass (file ops < 10ms, transitions < 50ms)
4. No critical bugs or data corruption under concurrent load
5. Complete API documentation with examples
6. Validation script passes all checks

Foundation layer provides:
- File-system-as-source-of-truth with atomic operations
- State machine with validated transitions
- Concurrency control (locking + CAS)
- Security (authentication + rate limiting)
- Real-time file watching with debouncing

Ready for Plan 02: Workflow Engine implementation.
</success_criteria>

<output>
After completion, create:
1. `.planning/project-task-management-system/phase-01-foundation/01-01-SUMMARY.md` - Phase execution summary
2. Test coverage report at `coverage/index.html`
3. Performance metrics at `benchmarks/metrics.json`
4. Foundation validation report at `foundation-validation.json`
</output>
