# Phase 02: File System Structure Setup

## EARS Framework

### Event (Trigger)
- Architecture approved and implementation begins
- Need to create workspace directories and file watching infrastructure

### Action (What We'll Do)
- Create complete workspace directory structure
- Implement file system abstraction layer
- Set up file watcher with event handling
- Add atomic file operations with locking
- Create file system tests

### Result (Outcome)
- Fully functional workspace directory structure
- File system watcher detecting all state.json changes
- Atomic file operations with guaranteed consistency
- Comprehensive test coverage for file layer

### Success Criteria
- [ ] All workspace directories created with correct permissions
- [ ] File watcher detects CLOSE_WRITE events on state.json files
- [ ] Atomic write operations never corrupt files (tested with kill -9)
- [ ] File locks prevent race conditions (tested with concurrent writers)
- [ ] Debouncing prevents duplicate events (tested with rapid writes)

---

## Specification

### Workspace Directory Structure

Create the following directory tree:

```
workspace/
├── inbox/                    # New projects enter here
│   ├── .gitkeep
│   └── README.md             # Instructions for creating projects
├── backlog/                  # Scheduled/queued projects
│   └── .gitkeep
├── active/                   # Currently executing
│   ├── unassigned/           # Tasks waiting for agent pickup
│   │   └── .gitkeep
│   └── assigned/            # Agent-owned subdirectories
│       └── .gitkeep
├── review/                   # Pending human approval
│   └── .gitkeep
├── completed/                # Successful completions
│   └── .gitkeep
├── failed/                   # Failed with error logs
│   └── .gitkeep
└── notifications/            # Event logs (JSON files)
    └── .gitkeep
```

**Directory Creation Rules:**
- Create with `mkdir -p` (create intermediate directories)
- Set permissions to `0755` (rwxr-xr-x)
- Create empty `.gitkeep` files in empty directories (to track in git)
- Add README.md in inbox/ with instructions

### Project Folder Structure

When a project is created, its folder structure is:

```
{project_id}/
├── state.json               # Atomic state file (single source of truth)
├── project.md               # Human-readable project description
├── cards/                   # Task cards
│   ├── 001-research.md
│   ├── 002-code.md
│   └── 003-test.md
├── outputs/                 # Generated by agents (task outputs)
│   └── .gitkeep
├── logs/                    # Execution logs
│   └── .gitkeep
└── .state.lock              # POSIX lock file (not in git)
```

### State.json Schema (Version 1.0)

```typescript
interface ProjectState {
  // Metadata
  schema_version: "1.0";
  project_id: string;           // UUID v4
  project_name: string;

  // State management
  state: ProjectState;
  created_at: string;           // ISO8601 datetime
  updated_at: string;           // ISO8601 datetime (updated on any change)

  // Assignment
  assignee_agent: string | null; // agent-id or null

  // Checkpoint handling
  checkpoint_required: boolean;
  checkpoint_approved: boolean | null;

  // Retry tracking
  retry_count: number;

  // Card tracking
  cards_total: number;
  cards_completed: number;
  cards_failed: number;

  // Detailed card states
  cards: CardState[];
}

type ProjectState =
  | "inbox"
  | "backlog"
  | "active"
  | "review"
  | "completed"
  | "failed";

interface CardState {
  card_id: string;              // UUID v4
  filename: string;             // e.g., "001-research.md"
  state: CardStateType;
  assignee: string | null;
  started_at: string | null;
  completed_at: string | null;
  failed_at: string | null;
  retry_count: number;
  dependencies: string[];       // card_id dependencies
  checkpoint_after: boolean;   // Require human review after this card
}

type CardStateType =
  | "pending"
  | "in-progress"
  | "completed"
  | "failed"
  | "blocked";
```

### Card File Format (Markdown with YAML Frontmatter)

```markdown
---
card_id: "abc-123-def"
type: "task"                 # task | meta | checkpoint | notification
project_id: "project-uuid"
sequence: 1                  # Display order in UI
state: "pending"              # pending | in-progress | completed | failed | blocked
priority: 2                  # 1-5 (1 = highest)
created: "2026-01-31T10:00:00Z"
started: null
completed: null
due: "2026-02-01T10:00:00Z"
assignee: "agent-researcher-01"
atomic: true
estimated_duration: "15m"
max_duration_minutes: 15
tags: ["research", "web-search"]
dependencies: []             # card_ids that must complete first
outputs_expected:
  - "research-findings.json"
failure_handling: "retry"
retry_count: 0
retry_max: 3
agent_profile: "researcher"
checkpoint_after: false
---

# Research Competitor Pricing

## Objective
Gather pricing information for top 3 competitors and compile into structured JSON.

## Context
We need to understand market positioning for our SaaS product. Focus on monthly subscription tiers and feature comparisons.

## Instructions
1. Visit competitor websites:
   - Competitor A: https://example-a.com/pricing
   - Competitor B: https://example-b.com/pricing
   - Competitor C: https://example-c.com/pricing
2. Extract pricing tiers (names, monthly cost, features)
3. Identify any promotional pricing or discounts
4. Format findings as JSON in outputs/research-findings.json

## Input Files
None (external web research)

## Output Files
- `outputs/research-findings.json` - Structured pricing data

## Success Criteria
- [ ] Pricing data for all 3 competitors extracted
- [ ] JSON schema validated against expected format
- [ ] Data accuracy verified by cross-referencing multiple sources

## Notes
Agent scratchpad for intermediate findings...
```

### File System Abstraction Layer

Create `src/core/FileSystem.ts` with the following interface:

```typescript
import { WatchEvent } from "chokidar";

/**
 * Result type for fallible operations
 */
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

/**
 * File system abstraction interface
 */
export interface IFileSystem {
  /**
   * Read project state.json atomically
   */
  readProject(projectId: string): Promise<Result<ProjectState>>;

  /**
   * Write project state.json atomically (with locking)
   */
  writeProject(
    projectId: string,
    state: ProjectState,
    options?: { retryAttempts?: number }
  ): Promise<Result<void>>;

  /**
   * Read card markdown file
   */
  readCard(projectId: string, filename: string): Promise<Result<Card>>;

  /**
   * Write card markdown file atomically
   */
  writeCard(
    projectId: string,
    filename: string,
    card: Card
  ): Promise<Result<void>>;

  /**
   * Move project folder between states (atomic)
   */
  moveProject(
    projectId: string,
    fromState: ProjectState,
    toState: ProjectState
  ): Promise<Result<void>>;

  /**
   * List all projects in a state folder
   */
  listProjects(state: ProjectState): Promise<Result<string[]>>;

  /**
   * Create new project folder with initial state
   */
  createProject(
    projectId: string,
    initialState: ProjectState,
    projectMd: string
  ): Promise<Result<void>>;

  /**
   * Delete project folder (cleanup)
   */
  deleteProject(projectId: string): Promise<Result<void>>;

  /**
   * Acquire lock on project
   * Returns lock file descriptor or error if locked
   */
  acquireLock(
    projectId: string,
    timeoutMs: number
  ): Promise<Result<number>>; // File descriptor

  /**
   * Release lock on project
   */
  releaseLock(projectId: string, fd: number): Promise<Result<void>>;

  /**
   * Watch for state.json changes across all state folders
   */
  watchStateChanges(callback: (event: WatchEvent) => void): () => void; // Returns cleanup function
}

/**
 * Card with parsed frontmatter and content
 */
export interface Card {
  frontmatter: CardFrontmatter;
  content: string;
  path: string;
}

export interface CardFrontmatter {
  card_id: string;
  type: string;
  project_id: string;
  sequence: number;
  state: string;
  priority: number;
  created: string;
  started: string | null;
  completed: string | null;
  due: string | null;
  assignee: string | null;
  atomic: boolean;
  estimated_duration: string;
  max_duration_minutes: number;
  tags: string[];
  dependencies: string[];
  outputs_expected: string[];
  failure_handling: string;
  retry_count: number;
  retry_max: number;
  agent_profile: string;
  checkpoint_after: boolean;
}
```

### Atomic Write Implementation

All writes to `state.json` must be atomic:

```typescript
async function atomicWrite(
  filePath: string,
  data: string
): Promise<Result<void>> {
  const tempPath = `${filePath}.tmp.${Date.now()}`;
  try {
    // 1. Write to temporary file
    await Bun.write(tempPath, data);

    // 2. Sync to disk (fsync equivalent)
    // Note: Bun.write may buffer, so we need explicit sync
    const file = Bun.file(tempPath);
    await file.stream().cancel(); // Force flush

    // 3. Atomic rename (POSIX guarantee)
    await Bun.rename(tempPath, filePath);

    return { success: true, data: undefined };
  } catch (error) {
    // Cleanup temp file on error
    try {
      await Bun.remove(tempPath);
    } catch (cleanupError) {
      // Ignore cleanup errors
    }
    return { success: false, error: error as Error };
  }
}
```

### File Locking Implementation

Use POSIX `flock()` for exclusive locks:

```typescript
import { open, close, flock } from "fs/promises";
import { constants as fsConstants } from "fs";

async function acquireLock(
  lockPath: string,
  timeoutMs: number = 5000
): Promise<Result<number>> {
  const startTime = Date.now();
  let attempts = 0;

  while (Date.now() - startTime < timeoutMs) {
    attempts++;
    try {
      const fd = await open(lockPath, fsConstants.O_WRONLY | fsConstants.O_CREAT, 0644);

      // Try to acquire exclusive lock (LOCK_EX), non-blocking (LOCK_NB)
      await flock(fd, fsConstants.LOCK_EX | fsConstants.LOCK_NB);

      // Lock acquired!
      return { success: true, data: fd };
    } catch (error: any) {
      // EWOULDBLOCK means lock is held by another process
      if (error.code === "EWOULDBLOCK") {
        // Exponential backoff: 10ms, 40ms, 160ms, 640ms, 2560ms
        const backoffMs = Math.min(10 * Math.pow(4, attempts - 1), 2560);
        await new Promise((resolve) => setTimeout(resolve, backoffMs));
        continue;
      }
      return { success: false, error };
    }
  }

  return {
    success: false,
    error: new Error(`Failed to acquire lock after ${timeoutMs}ms`),
  };
}

async function releaseLock(
  lockPath: string,
  fd: number
): Promise<Result<void>> {
  try {
    await flock(fd, fsConstants.LOCK_UN);
    await close(fd);
    return { success: true, data: undefined };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

### File Watcher Implementation

Use `chokidar` for cross-platform file watching:

```typescript
import chokidar from "chokidar";

export interface WatchEvent {
  type: "add" | "change" | "unlink";
  path: string;
  projectId?: string; // Extracted from path
}

function createWatcher(
  workspaceRoot: string,
  callback: (event: WatchEvent) => void
): () => void {
  const stateFolders = [
    "inbox",
    "backlog",
    "active",
    "review",
    "completed",
    "failed",
  ].map((folder) => `${workspaceRoot}/${folder}`);

  const watcher = chokidar.watch(stateFolders, {
    ignored: /(^\..+|[\/\\]\..+)/, // Ignore dotfiles
    persistent: true,
    ignoreInitial: true, // Don't fire for existing files
    awaitWriteFinish: {
      stabilityThreshold: 100, // ms
      pollInterval: 10,
    },
  });

  // Debounce function to batch rapid changes
  let debounceTimeouts = new Map<string, NodeJS.Timeout>();

  const processEvent = (event: string, path: string) => {
    // Only process state.json files
    if (!path.endsWith("/state.json")) return;

    // Extract project ID from path
    const match = path.match(/\/([^/]+)\/state\.json$/);
    if (!match) return;
    const projectId = match[1];

    // Clear existing timeout for this file
    const existingTimeout = debounceTimeouts.get(path);
    if (existingTimeout) clearTimeout(existingTimeout);

    // Debounce: wait 100ms after last change
    const timeout = setTimeout(() => {
      callback({
        type: event === "add" ? "add" : event === "change" ? "change" : "unlink",
        path,
        projectId,
      });
      debounceTimeouts.delete(path);
    }, 100);

    debounceTimeouts.set(path, timeout);
  };

  watcher
    .on("add", (path) => processEvent("add", path))
    .on("change", (path) => processEvent("change", path))
    .on("unlink", (path) => processEvent("unlink", path))
    .on("error", (error) => {
      console.error(`[FileSystem] Watcher error:`, error);
    });

  // Return cleanup function
  return () => {
    debounceTimeouts.forEach((timeout) => clearTimeout(timeout));
    watcher.close();
  };
}
```

### Directory Initialization Script

Create `scripts/init-workspace.ts`:

```typescript
import { mkdir, writeFile } from "fs/promises";
import { join } from "path";

const STATE_FOLDERS = [
  "inbox",
  "backlog",
  "active/unassigned",
  "active/assigned",
  "review",
  "completed",
  "failed",
  "notifications",
];

async function initWorkspace(root: string = "workspace") {
  console.log(`Initializing workspace at ${root}...`);

  // Create directories
  for (const folder of STATE_FOLDERS) {
    const path = join(root, folder);
    await mkdir(path, { recursive: true });
    await writeFile(join(path, ".gitkeep"), "");
    console.log(`✓ Created ${folder}/`);
  }

  // Add README to inbox/
  const inboxReadme = `# Inbox Folder

This folder receives new projects before they are processed.

## Creating a New Project

To create a new project:

1. Create a folder with a UUID v4 name: \`{uuid}/\`
2. Create \`state.json\` with the following structure:
   \`\`\`json
   {
     "schema_version": "1.0",
     "project_id": "uuid",
     "project_name": "Project Name",
     "state": "inbox",
     "created_at": "ISO8601",
     "updated_at": "ISO8601",
     "assignee_agent": null,
     "checkpoint_required": false,
     "checkpoint_approved": null,
     "retry_count": 0,
     "cards_total": 0,
     "cards_completed": 0,
     "cards_failed": 0,
     "cards": []
   }
   \`\`\`
3. Create \`project.md\` with project description
4. Create \`cards/\` folder and add task cards (Markdown with frontmatter)

## Automatic Processing

Projects in \`inbox/\` are automatically moved to \`backlog/\` when:
- \`state.json\` is valid JSON
- Required fields are present
- No validation errors occur
`;

  await writeFile(join(root, "inbox", "README.md"), inboxReadme);
  console.log(`✓ Created inbox/README.md`);

  console.log(`\n✓ Workspace initialized successfully!`);
}

// Run if executed directly
if (import.meta.main) {
  initWorkspace(process.argv[2] || "workspace");
}
```

### Tests

Create comprehensive tests in `tests/core/FileSystem.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { FileSystem } from "../../src/core/FileSystem";
import { mkdir, rmdir, writeFile } from "fs/promises";
import { join, tmpdir } from "path";

const TEST_DIR = join(tmpdir(), "fs-test");

describe("FileSystem", () => {
  let fs: FileSystem;

  beforeEach(async () => {
    await mkdir(TEST_DIR, { recursive: true });
    fs = new FileSystem(TEST_DIR);
  });

  afterEach(async () => {
    await rmdir(TEST_DIR, { recursive: true });
  });

  describe("writeProject - atomicity", () => {
    it("should write state.json atomically", async () => {
      const projectId = "test-project-1";
      const state = createMockState(projectId);

      const result = await fs.writeProject(projectId, state);
      expect(result.success).toBe(true);

      // Verify file exists and is valid
      const readResult = await fs.readProject(projectId);
      expect(readResult.success).toBe(true);
      expect(readResult.data.project_id).toBe(projectId);
    });

    it("should not corrupt file on partial write", async () => {
      const projectId = "test-project-2";
      const state = createMockState(projectId);

      // Simulate interrupted write (kill during write)
      const writePromise = fs.writeProject(projectId, state);
      // Force process exit during write (testing, don't actually do this in production)
      // process.exit(1);

      // In production: use atomic write (write temp + rename)
      // This ensures either old file or new file exists, never partial
    });
  });

  describe("locking", () => {
    it("should prevent concurrent writes", async () => {
      const projectId = "test-project-3";
      const state1 = createMockState(projectId, "Project 1");
      const state2 = createMockState(projectId, "Project 2");

      // Acquire lock 1
      const lock1 = await fs.acquireLock(projectId, 5000);
      expect(lock1.success).toBe(true);

      // Try to acquire lock 2 (should timeout)
      const lock2 = await fs.acquireLock(projectId, 100);
      expect(lock2.success).toBe(false);

      // Release lock 1
      await fs.releaseLock(projectId, lock1.data);

      // Now lock 2 should succeed
      const lock3 = await fs.acquireLock(projectId, 100);
      expect(lock3.success).toBe(true);
    });

    it("should timeout after configured duration", async () => {
      const projectId = "test-project-4";

      const lock1 = await fs.acquireLock(projectId, 5000);
      const lock2 = await fs.acquireLock(projectId, 100);

      expect(lock2.success).toBe(false);
      expect(lock2.error?.message).toContain("timeout");
    });
  });

  describe("moveProject", () => {
    it("should move project folder atomically", async () => {
      const projectId = "test-project-5";
      await fs.createProject(projectId, createMockState(projectId), "Test");

      const result = await fs.moveProject(projectId, "inbox", "backlog");
      expect(result.success).toBe(true);

      // Verify project exists in new location
      const inboxList = await fs.listProjects("inbox");
      expect(inboxList.success).toBe(true);
      expect(inboxList.data).not.toContain(projectId);

      const backlogList = await fs.listProjects("backlog");
      expect(backlogList.success).toBe(true);
      expect(backlogList.data).toContain(projectId);
    });
  });

  describe("watcher", () => {
    it("should detect state.json changes", async () => {
      const events: any[] = [];
      const cleanup = fs.watchStateChanges((event) => events.push(event));

      // Wait for watcher to initialize
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Write a state.json
      const projectId = "test-project-6";
      await fs.createProject(projectId, createMockState(projectId), "Test");

      // Wait for debounced event
      await new Promise((resolve) => setTimeout(resolve, 200));

      expect(events.length).toBeGreaterThan(0);
      expect(events[0].projectId).toBe(projectId);
      expect(events[0].path).toContain("state.json");

      cleanup();
    });
  });
});

function createMockState(projectId: string, name: string = "Test"): ProjectState {
  return {
    schema_version: "1.0",
    project_id: projectId,
    project_name: name,
    state: "inbox",
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    assignee_agent: null,
    checkpoint_required: false,
    checkpoint_approved: null,
    retry_count: 0,
    cards_total: 0,
    cards_completed: 0,
    cards_failed: 0,
    cards: [],
  };
}
```

---

## Implementation Steps

1. **Create directory structure**
   - Run `bun run scripts/init-workspace.ts`
   - Verify all folders exist with correct permissions

2. **Implement FileSystem class**
   - Create `src/core/FileSystem.ts`
   - Implement atomic write with temp + rename
   - Implement file locking with flock
   - Implement all IFileSystem interface methods

3. **Implement file watcher**
   - Set up chokidar for all state folders
   - Add debouncing (100ms stability threshold)
   - Extract project IDs from paths
   - Call callback with structured WatchEvent

4. **Create tests**
   - Test atomic writes (no corruption)
   - Test concurrent writes (locking works)
   - Test file watcher (events fire correctly)
   - Test move operations (folders move atomically)

5. **Run test suite**
   - `bun test tests/core/FileSystem.test.ts`
   - All tests must pass

---

## Deliverables

1. **Workspace directory structure** (created by init script)
2. **`src/core/FileSystem.ts`** - File system abstraction layer
3. **`scripts/init-workspace.ts`** - Workspace initialization script
4. **`tests/core/FileSystem.test.ts`** - Comprehensive test suite
5. **TypeScript types** for all interfaces

---

## Next Phase

After file system layer is complete, proceed to **Phase 03: Data Model & Types Definition** to define TypeScript interfaces and schemas for all domain objects.
